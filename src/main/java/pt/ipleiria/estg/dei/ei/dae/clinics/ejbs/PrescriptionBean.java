package pt.ipleiria.estg.dei.ei.dae.clinics.ejbs;

import pt.ipleiria.estg.dei.ei.dae.clinics.entities.*;
import pt.ipleiria.estg.dei.ei.dae.clinics.exceptions.MyEntityExistsException;
import pt.ipleiria.estg.dei.ei.dae.clinics.exceptions.MyEntityNotFoundException;
import pt.ipleiria.estg.dei.ei.dae.clinics.exceptions.MyIllegalArgumentException;
import pt.ipleiria.estg.dei.ei.dae.clinics.exceptions.MyUnauthorizedException;

import javax.ejb.Stateless;
import javax.persistence.EntityManager;
import javax.persistence.LockModeType;
import javax.persistence.PersistenceContext;
import javax.persistence.TypedQuery;

import java.text.ParseException;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

@Stateless
public class PrescriptionBean {
    @PersistenceContext
    private EntityManager entityManager;

    public Prescription findPrescription(long id) throws MyEntityNotFoundException {
        Prescription prescription = entityManager.find(Prescription.class, id);
        if (prescription == null || prescription.getDeleted_at() != null)
            throw new MyEntityNotFoundException("Prescription \"" + id + "\" does not exist");

        return prescription;
    }

    public BiometricDataIssue findBiometricDataIssue(long id) {
        return entityManager.find(BiometricDataIssue.class, id);
    }

    public List<Prescription> getAllPrescriptionByPatient(long id) {
        return entityManager.createNamedQuery("getAllPrescriptionsByPatient", Prescription.class).setParameter("id", id).setLockMode(LockModeType.OPTIMISTIC).getResultList();
    }

    public List<Prescription> getAllPrescriptionByHealthcareProfessional(long id) {
        return entityManager.createNamedQuery("getAllPrescriptionsByHealthcareProfessional", Prescription.class).setParameter("id", id).setLockMode(LockModeType.OPTIMISTIC).getResultList();
    }

    /***
     * Creating a Prescription by a Doctor given some Biometric Data Issues
     * 
     * @param healthcareProfessionalId   Healthcare Professional Id that is
     *                                   creating the current Prescription
     * @param start_date                 that Prescription is starting
     * @param end_date                   that Prescription is ending
     * @param notes                      given by Doctor, the content of
     *                                   Prescription
     * @param biometricDataIssues        Biometric Data Issues that this
     *                                   Prescription will affect
     * @return @Id generated by autoincrement
     *         null if Not a found Doctor with this username
     *         null if Not found Biometric Data Issue with this id
     *         (bio_data_issues_id)
     */
    public long create(long healthcareProfessionalId, String start_date, String end_date, String notes,
            List<BiometricDataIssue> biometricDataIssues) throws ParseException, MyEntityNotFoundException, MyIllegalArgumentException {

        HealthcareProfessional healthcareProfessional = entityManager.find(HealthcareProfessional.class, healthcareProfessionalId);
        if (healthcareProfessional == null || healthcareProfessional.getDeleted_at() != null)
            throw new MyEntityNotFoundException("Healthcare Professional \"" + healthcareProfessionalId + "\" does not exist");

        //REQUIRED VALIDATION
        if (start_date == null || start_date.trim().isEmpty())
            throw new MyIllegalArgumentException("Field \"start_date\" is required");
        if (end_date == null || end_date.trim().isEmpty())
            throw new MyIllegalArgumentException("Field \"end_date\" is required");
        if (biometricDataIssues == null || biometricDataIssues.size() == 0)
            throw new MyIllegalArgumentException("You need to have at least 1 biometric data issue");
        if (notes == null || notes.trim().isEmpty())
            throw new MyIllegalArgumentException("Field \"notes\" is required");

        //CHECK VALUES
        if (compareDates(start_date.trim(), LocalDateTime.now().atZone(ZoneId.systemDefault()).minusMinutes(1).format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm"))) < 0)
            throw new MyIllegalArgumentException("Field \"start_date\" should be higher or equal than the current date");
        if (compareDates(start_date.trim(), end_date.trim()) >= 0)
            throw new MyIllegalArgumentException("Fields \"start_date\" and \"end_date\" need to have a valid time difference");

        Prescription prescription = new Prescription(healthcareProfessional, start_date.trim(), end_date.trim(), notes.trim(), biometricDataIssues);

        for (BiometricDataIssue issue : biometricDataIssues) {
            issue.addPrescription(prescription);
        }

        healthcareProfessional.addPrescription(prescription);

        entityManager.persist(prescription);
        entityManager.flush();

        return prescription.getId();
    }

    /***
     * Delete a Prescription by given @Id:id
     * 
     * @param id @Id to find the proposal delete Prescription
     */
    public boolean delete(long id, long personId) throws MyEntityNotFoundException, MyUnauthorizedException {
        Prescription prescription = findPrescription(id);
        entityManager.lock(prescription, LockModeType.PESSIMISTIC_WRITE);
        if (prescription.getHealthcareProfessional().getId() != personId)
            throw new MyUnauthorizedException("You are not allowed to delete this prescription");

        //REMOVE DEPENDENCIES
        /*HealthcareProfessional healthcareProfessional = prescription.getHealthcareProfessional();
        List<Patient> patients = prescription.getPatients();
        List<BiometricDataIssue> biometricDataIssues = prescription.getBiometric_data_issue();

        healthcareProfessional.removePrescription(prescription);
        for (Patient patient : patients) {
            patient.removePrescription(prescription);
        }
        for (BiometricDataIssue biometricDataIssue : biometricDataIssues) {
            biometricDataIssue.removePrescription(prescription);
        }
        entityManager.remove(prescription);
        return entityManager.find(Prescription.class, id) == null;
        */

        prescription.setDeleted_at();
        return true;
    }

    /***
     * Restore a Prescription by given @Id:id - Change deleted_at field to null date
     * @param id @Id to find the proposal restore Observation
     */
    public boolean restore(long id) throws MyEntityNotFoundException, MyEntityExistsException {
        Prescription prescription = entityManager.find(Prescription.class, id);
        if (prescription == null)
            throw new MyEntityNotFoundException("Prescription \"" + id + "\" does not exist");
        if (prescription.getDeleted_at() == null)
            throw new MyEntityExistsException("Prescription \"" + id + "\" already exist");
        prescription.setDeleted_at(null);

        return true;
    }

    /***
     * Update a Biometric Data Issue by given @Id:id
     * 
     * @param id                  @Id to find the proposal update Biometric Data
     *                            Issue
     * @param start_date          to update Biometric Data Issue
     * @param end_date            to update Biometric Data Issue
     * @param notes               to update Biometric Data Issue
     * @param biometricDataIssues to update Biometric Data Issue
     */
    public void update(long id, String start_date, String end_date, String notes,
                       List<BiometricDataIssue> biometricDataIssues, long personId) throws ParseException, MyEntityNotFoundException, MyIllegalArgumentException, MyUnauthorizedException {
        Prescription prescription = findPrescription(id);
        if (prescription.getHealthcareProfessional().getId() != personId)
            throw new MyUnauthorizedException("You are not allowed to modify this prescription");
        if (prescription.getEnd_date().compareTo(LocalDateTime.now()) < 0)
            throw new MyIllegalArgumentException("This prescription is from the past, so you are not allowed to modify it");

        entityManager.lock(prescription, LockModeType.PESSIMISTIC_FORCE_INCREMENT);

        //REQUIRED VALIDATION
        if (start_date == null || start_date.trim().isEmpty())
            throw new MyIllegalArgumentException("Field \"start_date\" is required");
        if (end_date == null || end_date.trim().isEmpty())
            throw new MyIllegalArgumentException("Field \"end_date\" is required");
        if (notes == null || notes.trim().isEmpty())
            throw new MyIllegalArgumentException("Field \"notes\" is required");

        //CHECK VALUES
        if (compareDates(start_date.trim(), end_date.trim()) >= 0)
            throw new MyIllegalArgumentException("Fields \"start_date\" and \"end_date\" need to have a valid time difference");

        boolean isGlobalPrescription = prescription.getBiometric_data_issue().size() > 0;
        if (isGlobalPrescription) {
            if (biometricDataIssues == null || biometricDataIssues.size() == 0)
                throw new MyIllegalArgumentException("You need to have at least 1 biometric data issue");
        }

        prescription.setStart_date(start_date.trim());
        prescription.setEnd_date(end_date.trim());
        prescription.setNotes(notes.trim());

        if (!isGlobalPrescription)
            return;

        for (BiometricDataIssue oldBiometricDataIssue : prescription.getBiometric_data_issue()) {
            //IF THERE IS ANY REMOVAL OF ISSUES FROM GLOBAL PRESCRIPTION, ALL PATIENT ARE UNLINKED TO THE PRESCRIPTION
            if (!biometricDataIssues.contains(oldBiometricDataIssue)) {
                oldBiometricDataIssue.removePrescription(prescription);
                for (Patient patient : prescription.getPatients()) {
                    patient.removePrescription(prescription);
                    prescription.removePatient(patient);
                }
                break;
            }
        }

        for (BiometricDataIssue biometricDataIssue : biometricDataIssues) {
            biometricDataIssue.addPrescription(prescription);
            prescription.addBiometricDataIssue(biometricDataIssue);
        }
    }

    /**
     *
     * @param date1
     * @param date2
     * @return 0 if @date1 is equals @date2, 1 if @d1 is greater then @d2, -1 if @d2 is greater then @d1
     */
    private int compareDates(String date1,String date2) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
        LocalDateTime d1 = LocalDateTime.parse(date1,formatter);
        LocalDateTime d2 = LocalDateTime.parse(date2,formatter);

        return d1.compareTo(d2); // -1 -> date1 < date2 | 0 -> date1 = date2 | 1 -> date1 > date2
    }

    public List<Prescription> getActivePrescriptionsByPatient(long patientId) {
        return entityManager.createNamedQuery("getActivePrescriptionsByPatient", Prescription.class).setParameter("id", patientId).setLockMode(LockModeType.OPTIMISTIC).getResultList();
    }
}
